#!/usr/bin/env python3

"""Generate views with unnested list and map fields."""

from argparse import ArgumentParser
from textwrap import dedent
import json
import subprocess
import sys


def replace(field, unnest_layer=0, *prefix):
    """Convert BigQuery field to a SQL expression for use in a REPLACE block."""
    if field["type"] == "RECORD":
        if len(field["fields"]) == 1:
            # prevent naming collisions via `UNNEST(...) AS`
            unnest_as = f"_{unnest_layer}"
            # handle lists
            if (
                field["fields"][0]["name"] == "list"
                and field["fields"][0]["mode"] == "REPEATED"
                and len(field["fields"][0]["fields"]) == 1
                and field["fields"][0]["fields"][0]["name"] == "element"
            ):
                unnest = ".".join(prefix + (field["name"], "list"))
                nested = replace(
                    field["fields"][0]["fields"][0], unnest_layer + 1, unnest_as
                )
                # handle simplest case without unnest_as
                if nested == f"{unnest_as}.element":
                    return f"ARRAY(SELECT * FROM UNNEST({unnest})) AS {field['name']}"
            # handle maps
            elif (
                field["fields"][0]["name"] == "key_value"
                and field["fields"][0]["mode"] == "REPEATED"
            ):
                unnest = ".".join(prefix + (field["name"], "key_value"))
                nested = replace(
                    {
                        "fields": field["fields"][0]["fields"],
                        "name": unnest_as,
                        "type": "RECORD",
                    },
                    unnest_layer + 1,
                )
                # handle simplest case without array unnest_layer
                if nested == unnest_as:
                    return f"{unnest} AS {field['name']}"
            # shorten special case for nested struct
            special_prefix = f"(SELECT AS STRUCT {unnest_as}.* "
            if nested.startswith(special_prefix):
                index = len(special_prefix)
                suffix = nested[index:].rsplit(")", 1)[0]
                select = f"SELECT AS STRUCT * {suffix}"
            # shorten nested struct
            elif nested.startswith("(SELECT AS STRUCT"):
                select = nested[1:].rsplit(")", 1)[0]
            # handle nested array
            elif nested.startswith("ARRAY"):
                select = f"SELECT AS STRUCT {nested}"
            else:
                select = f"SELECT {nested}"
            from_ = f"FROM UNNEST({unnest}) AS {unnest_as}"
            return f"ARRAY({select} {from_}) AS {field['name']}"
        # handle other structs with nested replacements
        replacements = []
        for subfield in field["fields"]:
            replacement = replace(subfield, unnest_layer, *prefix, field["name"])
            if " AS " in replacement:
                replacements += [replacement]
        if replacements:
            select = f"SELECT AS STRUCT {'.'.join(prefix + (field['name'], '*'))}"
            replacements = ", ".join(replacements)
            return f"({select} REPLACE ({replacements})) AS {field['name']}"
    # no unnesting needed
    return ".".join(prefix + (field["name"],))


def generate(table, view, table_dataset, view_dataset, project):
    """Generate a CREATE VIEW statement that unnests lists and maps."""
    result = subprocess.check_output(
        [
            "bq",
            "show",
            "--project_id",
            project,
            "--dataset_id",
            table_dataset,
            "--schema",
            table,
        ]
    )
    schema = json.loads(result)
    replacements = []
    for field in schema:
        try:
            replacement = replace(field)
        except Exception:
            print(f"problem with field: {json.dumps(field, indent=2)}")
            raise
        if " AS " in replacement:
            replacements += [replacement]

    replacements.sort(key=lambda x: x.rsplit(" AS ", 1)[-1])

    return dedent(
        f"""
        -- Query generated by: {' '.join(sys.argv)}
        CREATE OR REPLACE VIEW
          `{project}.{view_dataset}.{view}` AS
        SELECT
          * REPLACE (
            """
        + f""",
            """.join(
            replacements
        )
        + f"""
          )
        FROM
          `{project}.{table_dataset}.{table}`
        """
    ).strip()


def main():
    """Parse argv and print CREATE VIEW statement."""
    parser = ArgumentParser(description=__doc__)
    parser.add_argument("table")
    parser.add_argument("view")
    parser.add_argument("--project", default="moz-fx-data-derived-datasets")
    parser.add_argument("--table-dataset", default="telemetry_raw")
    parser.add_argument("--view-dataset", default="telemetry")
    args = parser.parse_args()
    sql = generate(
        args.table, args.view, args.table_dataset, args.view_dataset, args.project
    )
    print(sql)


if __name__ == "__main__":
    main()
